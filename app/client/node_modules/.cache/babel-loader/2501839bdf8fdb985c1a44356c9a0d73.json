{"ast":null,"code":"var queue = [];\n/**\r\n  Variable to hold a counting semaphore\r\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\r\n    already suspended)\r\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\r\n    triggers flushing the queued tasks.\r\n**/\n\nvar semaphore = 0;\n/**\r\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\r\n  and flushed after this task has finished (assuming the scheduler endup in a released\r\n  state).\r\n**/\n\nfunction exec(task) {\n  try {\n    suspend();\n    task();\n  } finally {\n    release();\n  }\n}\n/**\r\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\r\n**/\n\n\nexport function asap(task) {\n  queue.push(task);\n\n  if (!semaphore) {\n    suspend();\n    flush();\n  }\n}\n/**\r\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\r\n  scheduler is released.\r\n**/\n\nexport function suspend() {\n  semaphore++;\n}\n/**\r\n  Puts the scheduler in a `released` state.\r\n**/\n\nfunction release() {\n  semaphore--;\n}\n/**\r\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\r\n**/\n\n\nexport function flush() {\n  release();\n  var task = void 0;\n\n  while (!semaphore && (task = queue.shift()) !== undefined) {\n    exec(task);\n  }\n}","map":{"version":3,"sources":["D:/Projets/group-790626/jobillet/client/node_modules/redux-saga/es/internal/scheduler.js"],"names":["queue","semaphore","exec","task","suspend","release","asap","push","flush","shift","undefined"],"mappings":"AAAA,IAAIA,KAAK,GAAG,EAAZ;AACA;;;;;;;;AAOA,IAAIC,SAAS,GAAG,CAAhB;AAEA;;;;;;AAKA,SAASC,IAAT,CAAcC,IAAd,EAAoB;AAClB,MAAI;AACFC,IAAAA,OAAO;AACPD,IAAAA,IAAI;AACL,GAHD,SAGU;AACRE,IAAAA,OAAO;AACR;AACF;AAED;;;;;AAGA,OAAO,SAASC,IAAT,CAAcH,IAAd,EAAoB;AACzBH,EAAAA,KAAK,CAACO,IAAN,CAAWJ,IAAX;;AAEA,MAAI,CAACF,SAAL,EAAgB;AACdG,IAAAA,OAAO;AACPI,IAAAA,KAAK;AACN;AACF;AAED;;;;;AAIA,OAAO,SAASJ,OAAT,GAAmB;AACxBH,EAAAA,SAAS;AACV;AAED;;;;AAGA,SAASI,OAAT,GAAmB;AACjBJ,EAAAA,SAAS;AACV;AAED;;;;;AAGA,OAAO,SAASO,KAAT,GAAiB;AACtBH,EAAAA,OAAO;AAEP,MAAIF,IAAI,GAAG,KAAK,CAAhB;;AACA,SAAO,CAACF,SAAD,IAAc,CAACE,IAAI,GAAGH,KAAK,CAACS,KAAN,EAAR,MAA2BC,SAAhD,EAA2D;AACzDR,IAAAA,IAAI,CAACC,IAAD,CAAJ;AACD;AACF","sourcesContent":["var queue = [];\r\n/**\r\n  Variable to hold a counting semaphore\r\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\r\n    already suspended)\r\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\r\n    triggers flushing the queued tasks.\r\n**/\r\nvar semaphore = 0;\r\n\r\n/**\r\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\r\n  and flushed after this task has finished (assuming the scheduler endup in a released\r\n  state).\r\n**/\r\nfunction exec(task) {\r\n  try {\r\n    suspend();\r\n    task();\r\n  } finally {\r\n    release();\r\n  }\r\n}\r\n\r\n/**\r\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\r\n**/\r\nexport function asap(task) {\r\n  queue.push(task);\r\n\r\n  if (!semaphore) {\r\n    suspend();\r\n    flush();\r\n  }\r\n}\r\n\r\n/**\r\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\r\n  scheduler is released.\r\n**/\r\nexport function suspend() {\r\n  semaphore++;\r\n}\r\n\r\n/**\r\n  Puts the scheduler in a `released` state.\r\n**/\r\nfunction release() {\r\n  semaphore--;\r\n}\r\n\r\n/**\r\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\r\n**/\r\nexport function flush() {\r\n  release();\r\n\r\n  var task = void 0;\r\n  while (!semaphore && (task = queue.shift()) !== undefined) {\r\n    exec(task);\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}