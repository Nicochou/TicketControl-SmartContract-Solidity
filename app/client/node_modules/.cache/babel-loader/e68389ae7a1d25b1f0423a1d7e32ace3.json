{"ast":null,"code":"\"use strict\";\n/**\r\n *  BigNumber\r\n *\r\n *  A wrapper around the BN.js object. We use the BN.js library\r\n *  because it is used by elliptic, so it is required regardles.\r\n *\r\n */\n\nimport _classCallCheck from \"D:\\\\Projets\\\\group-790626\\\\jobillet\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Projets\\\\group-790626\\\\jobillet\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { BN } from \"bn.js\";\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar _constructorGuard = {};\nvar MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n  return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === \"bigint\" || isBytes(value));\n}\nexport var BigNumber = /*#__PURE__*/function () {\n  function BigNumber(constructorGuard, hex) {\n    _classCallCheck(this, BigNumber);\n\n    logger.checkNew(this instanceof BigNumber ? this.constructor : void 0, BigNumber);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new (BigNumber)\"\n      });\n    }\n\n    this._hex = hex;\n    this._isBigNumber = true;\n    Object.freeze(this);\n  }\n\n  _createClass(BigNumber, [{\n    key: \"fromTwos\",\n    value: function fromTwos(value) {\n      return toBigNumber(toBN(this).fromTwos(value));\n    }\n  }, {\n    key: \"toTwos\",\n    value: function toTwos(value) {\n      return toBigNumber(toBN(this).toTwos(value));\n    }\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      if (this._hex[0] === \"-\") {\n        return BigNumber.from(this._hex.substring(1));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return toBigNumber(toBN(this).add(toBN(other)));\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(other) {\n      return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n  }, {\n    key: \"div\",\n    value: function div(other) {\n      var o = BigNumber.from(other);\n\n      if (o.isZero()) {\n        throwFault(\"division by zero\", \"div\");\n      }\n\n      return toBigNumber(toBN(this).div(toBN(other)));\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(other) {\n      return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n  }, {\n    key: \"mod\",\n    value: function mod(other) {\n      var value = toBN(other);\n\n      if (value.isNeg()) {\n        throwFault(\"cannot modulo negative values\", \"mod\");\n      }\n\n      return toBigNumber(toBN(this).umod(value));\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(other) {\n      var value = toBN(other);\n\n      if (value.isNeg()) {\n        throwFault(\"cannot raise to negative values\", \"pow\");\n      }\n\n      return toBigNumber(toBN(this).pow(value));\n    }\n  }, {\n    key: \"and\",\n    value: function and(other) {\n      var value = toBN(other);\n\n      if (this.isNegative() || value.isNeg()) {\n        throwFault(\"cannot 'and' negative values\", \"and\");\n      }\n\n      return toBigNumber(toBN(this).and(value));\n    }\n  }, {\n    key: \"or\",\n    value: function or(other) {\n      var value = toBN(other);\n\n      if (this.isNegative() || value.isNeg()) {\n        throwFault(\"cannot 'or' negative values\", \"or\");\n      }\n\n      return toBigNumber(toBN(this).or(value));\n    }\n  }, {\n    key: \"xor\",\n    value: function xor(other) {\n      var value = toBN(other);\n\n      if (this.isNegative() || value.isNeg()) {\n        throwFault(\"cannot 'xor' negative values\", \"xor\");\n      }\n\n      return toBigNumber(toBN(this).xor(value));\n    }\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      if (this.isNegative() || value < 0) {\n        throwFault(\"cannot mask negative values\", \"mask\");\n      }\n\n      return toBigNumber(toBN(this).maskn(value));\n    }\n  }, {\n    key: \"shl\",\n    value: function shl(value) {\n      if (this.isNegative() || value < 0) {\n        throwFault(\"cannot shift negative values\", \"shl\");\n      }\n\n      return toBigNumber(toBN(this).shln(value));\n    }\n  }, {\n    key: \"shr\",\n    value: function shr(value) {\n      if (this.isNegative() || value < 0) {\n        throwFault(\"cannot shift negative values\", \"shr\");\n      }\n\n      return toBigNumber(toBN(this).shrn(value));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return toBN(this).eq(toBN(other));\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(other) {\n      return toBN(this).lt(toBN(other));\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(other) {\n      return toBN(this).lte(toBN(other));\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(other) {\n      return toBN(this).gt(toBN(other));\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(other) {\n      return toBN(this).gte(toBN(other));\n    }\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return this._hex[0] === \"-\";\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return toBN(this).isZero();\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      try {\n        return toBN(this).toNumber();\n      } catch (error) {\n        throwFault(\"overflow\", \"toNumber\", this.toString());\n      }\n\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // Lots of people expect this, which we do not support, so check\n      if (arguments.length !== 0) {\n        logger.throwError(\"bigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      }\n\n      return toBN(this).toString(10);\n    }\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return this._hex;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(key) {\n      return {\n        type: \"BigNumber\",\n        hex: this.toHexString()\n      };\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof BigNumber) {\n        return value;\n      }\n\n      if (typeof value === \"string\") {\n        if (value.match(/^-?0x[0-9a-f]+$/i)) {\n          return new BigNumber(_constructorGuard, toHex(value));\n        }\n\n        if (value.match(/^-?[0-9]+$/)) {\n          return new BigNumber(_constructorGuard, toHex(new BN(value)));\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n      }\n\n      if (typeof value === \"number\") {\n        if (value % 1) {\n          throwFault(\"underflow\", \"BigNumber.from\", value);\n        }\n\n        if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n          throwFault(\"overflow\", \"BigNumber.from\", value);\n        }\n\n        return BigNumber.from(String(value));\n      }\n\n      var anyValue = value;\n\n      if (typeof anyValue === \"bigint\") {\n        return BigNumber.from(anyValue.toString());\n      }\n\n      if (isBytes(anyValue)) {\n        return BigNumber.from(hexlify(anyValue));\n      }\n\n      if (anyValue) {\n        // Hexable interface (takes piority)\n        if (anyValue.toHexString) {\n          var hex = anyValue.toHexString();\n\n          if (typeof hex === \"string\") {\n            return BigNumber.from(hex);\n          }\n        } else {\n          // For now, handle legacy JSON-ified values (goes away in v6)\n          var _hex = anyValue._hex; // New-form JSON\n\n          if (_hex == null && anyValue.type === \"BigNumber\") {\n            _hex = anyValue.hex;\n          }\n\n          if (typeof _hex === \"string\") {\n            if (isHexString(_hex) || _hex[0] === \"-\" && isHexString(_hex.substring(1))) {\n              return BigNumber.from(_hex);\n            }\n          }\n        }\n      }\n\n      return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n  }, {\n    key: \"isBigNumber\",\n    value: function isBigNumber(value) {\n      return !!(value && value._isBigNumber);\n    }\n  }]);\n\n  return BigNumber;\n}(); // Normalize the hex string\n\nfunction toHex(value) {\n  // For BN, call on the hex string\n  if (typeof value !== \"string\") {\n    return toHex(value.toString(16));\n  } // If negative, prepend the negative sign to the normalized positive value\n\n\n  if (value[0] === \"-\") {\n    // Strip off the negative sign\n    value = value.substring(1); // Cannot have mulitple negative signs (e.g. \"--0x04\")\n\n    if (value[0] === \"-\") {\n      logger.throwArgumentError(\"invalid hex\", \"value\", value);\n    } // Call toHex on the positive component\n\n\n    value = toHex(value); // Do not allow \"-0x00\"\n\n    if (value === \"0x00\") {\n      return value;\n    } // Negate the value\n\n\n    return \"-\" + value;\n  } // Add a \"0x\" prefix if missing\n\n\n  if (value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  } // Normalize zero\n\n\n  if (value === \"0x\") {\n    return \"0x00\";\n  } // Make the string even length\n\n\n  if (value.length % 2) {\n    value = \"0x0\" + value.substring(2);\n  } // Trim to smallest even-length string\n\n\n  while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n    value = \"0x\" + value.substring(4);\n  }\n\n  return value;\n}\n\nfunction toBigNumber(value) {\n  return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value) {\n  var hex = BigNumber.from(value).toHexString();\n\n  if (hex[0] === \"-\") {\n    return new BN(\"-\" + hex.substring(3), 16);\n  }\n\n  return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault, operation, value) {\n  var params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value != null) {\n    params.value = value;\n  }\n\n  return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}","map":{"version":3,"sources":["../src.ts/bignumber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n *  BigNumber\r\n *\r\n *  A wrapper around the BN.js object. We use the BN.js library\r\n *  because it is used by elliptic, so it is required regardles.\r\n *\r\n */\r\nimport { BN } from \"bn.js\";\r\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nconst _constructorGuard = {};\r\nconst MAX_SAFE = 0x1fffffffffffff;\r\nexport function isBigNumberish(value) {\r\n    return (value != null) && (BigNumber.isBigNumber(value) ||\r\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\r\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\r\n        isHexString(value) ||\r\n        (typeof (value) === \"bigint\") ||\r\n        isBytes(value));\r\n}\r\nexport class BigNumber {\r\n    constructor(constructorGuard, hex) {\r\n        logger.checkNew(new.target, BigNumber);\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new (BigNumber)\"\r\n            });\r\n        }\r\n        this._hex = hex;\r\n        this._isBigNumber = true;\r\n        Object.freeze(this);\r\n    }\r\n    fromTwos(value) {\r\n        return toBigNumber(toBN(this).fromTwos(value));\r\n    }\r\n    toTwos(value) {\r\n        return toBigNumber(toBN(this).toTwos(value));\r\n    }\r\n    abs() {\r\n        if (this._hex[0] === \"-\") {\r\n            return BigNumber.from(this._hex.substring(1));\r\n        }\r\n        return this;\r\n    }\r\n    add(other) {\r\n        return toBigNumber(toBN(this).add(toBN(other)));\r\n    }\r\n    sub(other) {\r\n        return toBigNumber(toBN(this).sub(toBN(other)));\r\n    }\r\n    div(other) {\r\n        const o = BigNumber.from(other);\r\n        if (o.isZero()) {\r\n            throwFault(\"division by zero\", \"div\");\r\n        }\r\n        return toBigNumber(toBN(this).div(toBN(other)));\r\n    }\r\n    mul(other) {\r\n        return toBigNumber(toBN(this).mul(toBN(other)));\r\n    }\r\n    mod(other) {\r\n        const value = toBN(other);\r\n        if (value.isNeg()) {\r\n            throwFault(\"cannot modulo negative values\", \"mod\");\r\n        }\r\n        return toBigNumber(toBN(this).umod(value));\r\n    }\r\n    pow(other) {\r\n        const value = toBN(other);\r\n        if (value.isNeg()) {\r\n            throwFault(\"cannot raise to negative values\", \"pow\");\r\n        }\r\n        return toBigNumber(toBN(this).pow(value));\r\n    }\r\n    and(other) {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"cannot 'and' negative values\", \"and\");\r\n        }\r\n        return toBigNumber(toBN(this).and(value));\r\n    }\r\n    or(other) {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"cannot 'or' negative values\", \"or\");\r\n        }\r\n        return toBigNumber(toBN(this).or(value));\r\n    }\r\n    xor(other) {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"cannot 'xor' negative values\", \"xor\");\r\n        }\r\n        return toBigNumber(toBN(this).xor(value));\r\n    }\r\n    mask(value) {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"cannot mask negative values\", \"mask\");\r\n        }\r\n        return toBigNumber(toBN(this).maskn(value));\r\n    }\r\n    shl(value) {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"cannot shift negative values\", \"shl\");\r\n        }\r\n        return toBigNumber(toBN(this).shln(value));\r\n    }\r\n    shr(value) {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"cannot shift negative values\", \"shr\");\r\n        }\r\n        return toBigNumber(toBN(this).shrn(value));\r\n    }\r\n    eq(other) {\r\n        return toBN(this).eq(toBN(other));\r\n    }\r\n    lt(other) {\r\n        return toBN(this).lt(toBN(other));\r\n    }\r\n    lte(other) {\r\n        return toBN(this).lte(toBN(other));\r\n    }\r\n    gt(other) {\r\n        return toBN(this).gt(toBN(other));\r\n    }\r\n    gte(other) {\r\n        return toBN(this).gte(toBN(other));\r\n    }\r\n    isNegative() {\r\n        return (this._hex[0] === \"-\");\r\n    }\r\n    isZero() {\r\n        return toBN(this).isZero();\r\n    }\r\n    toNumber() {\r\n        try {\r\n            return toBN(this).toNumber();\r\n        }\r\n        catch (error) {\r\n            throwFault(\"overflow\", \"toNumber\", this.toString());\r\n        }\r\n        return null;\r\n    }\r\n    toString() {\r\n        // Lots of people expect this, which we do not support, so check\r\n        if (arguments.length !== 0) {\r\n            logger.throwError(\"bigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\r\n        }\r\n        return toBN(this).toString(10);\r\n    }\r\n    toHexString() {\r\n        return this._hex;\r\n    }\r\n    toJSON(key) {\r\n        return { type: \"BigNumber\", hex: this.toHexString() };\r\n    }\r\n    static from(value) {\r\n        if (value instanceof BigNumber) {\r\n            return value;\r\n        }\r\n        if (typeof (value) === \"string\") {\r\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\r\n                return new BigNumber(_constructorGuard, toHex(value));\r\n            }\r\n            if (value.match(/^-?[0-9]+$/)) {\r\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\r\n            }\r\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\r\n        }\r\n        if (typeof (value) === \"number\") {\r\n            if (value % 1) {\r\n                throwFault(\"underflow\", \"BigNumber.from\", value);\r\n            }\r\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\r\n                throwFault(\"overflow\", \"BigNumber.from\", value);\r\n            }\r\n            return BigNumber.from(String(value));\r\n        }\r\n        const anyValue = value;\r\n        if (typeof (anyValue) === \"bigint\") {\r\n            return BigNumber.from(anyValue.toString());\r\n        }\r\n        if (isBytes(anyValue)) {\r\n            return BigNumber.from(hexlify(anyValue));\r\n        }\r\n        if (anyValue) {\r\n            // Hexable interface (takes piority)\r\n            if (anyValue.toHexString) {\r\n                const hex = anyValue.toHexString();\r\n                if (typeof (hex) === \"string\") {\r\n                    return BigNumber.from(hex);\r\n                }\r\n            }\r\n            else {\r\n                // For now, handle legacy JSON-ified values (goes away in v6)\r\n                let hex = anyValue._hex;\r\n                // New-form JSON\r\n                if (hex == null && anyValue.type === \"BigNumber\") {\r\n                    hex = anyValue.hex;\r\n                }\r\n                if (typeof (hex) === \"string\") {\r\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\r\n                        return BigNumber.from(hex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\r\n    }\r\n    static isBigNumber(value) {\r\n        return !!(value && value._isBigNumber);\r\n    }\r\n}\r\n// Normalize the hex string\r\nfunction toHex(value) {\r\n    // For BN, call on the hex string\r\n    if (typeof (value) !== \"string\") {\r\n        return toHex(value.toString(16));\r\n    }\r\n    // If negative, prepend the negative sign to the normalized positive value\r\n    if (value[0] === \"-\") {\r\n        // Strip off the negative sign\r\n        value = value.substring(1);\r\n        // Cannot have mulitple negative signs (e.g. \"--0x04\")\r\n        if (value[0] === \"-\") {\r\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\r\n        }\r\n        // Call toHex on the positive component\r\n        value = toHex(value);\r\n        // Do not allow \"-0x00\"\r\n        if (value === \"0x00\") {\r\n            return value;\r\n        }\r\n        // Negate the value\r\n        return \"-\" + value;\r\n    }\r\n    // Add a \"0x\" prefix if missing\r\n    if (value.substring(0, 2) !== \"0x\") {\r\n        value = \"0x\" + value;\r\n    }\r\n    // Normalize zero\r\n    if (value === \"0x\") {\r\n        return \"0x00\";\r\n    }\r\n    // Make the string even length\r\n    if (value.length % 2) {\r\n        value = \"0x0\" + value.substring(2);\r\n    }\r\n    // Trim to smallest even-length string\r\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\r\n        value = \"0x\" + value.substring(4);\r\n    }\r\n    return value;\r\n}\r\nfunction toBigNumber(value) {\r\n    return BigNumber.from(toHex(value));\r\n}\r\nfunction toBN(value) {\r\n    const hex = BigNumber.from(value).toHexString();\r\n    if (hex[0] === \"-\") {\r\n        return (new BN(\"-\" + hex.substring(3), 16));\r\n    }\r\n    return new BN(hex.substring(2), 16);\r\n}\r\nfunction throwFault(fault, operation, value) {\r\n    const params = { fault: fault, operation: operation };\r\n    if (value != null) {\r\n        params.value = value;\r\n    }\r\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\r\n}\r\n//# sourceMappingURL=bignumber.js.map"]},"metadata":{},"sourceType":"module"}