{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport { is, check, remove, MATCH, internalErr, SAGA_ACTION } from './utils';\nimport { buffers } from './buffers';\nimport { asap } from './scheduler';\nvar CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';\nexport var END = {\n  type: CHANNEL_END_TYPE\n};\nexport var isEnd = function isEnd(a) {\n  return a && a.type === CHANNEL_END_TYPE;\n};\nexport function emitter() {\n  var subscribers = [];\n\n  function subscribe(sub) {\n    subscribers.push(sub);\n    return function () {\n      return remove(subscribers, sub);\n    };\n  }\n\n  function emit(item) {\n    var arr = subscribers.slice();\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      arr[i](item);\n    }\n  }\n\n  return {\n    subscribe: subscribe,\n    emit: emit\n  };\n}\nexport var INVALID_BUFFER = 'invalid buffer passed to channel factory function';\nexport var UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';\n\nif (process.env.NODE_ENV !== 'production') {\n  UNDEFINED_INPUT_ERROR += '\\nHints:\\n    - check that your Action Creator returns a non-undefined value\\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\\n  ';\n}\n\nexport function channel() {\n  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : buffers.fixed();\n  var closed = false;\n  var takers = [];\n  check(buffer, is.buffer, INVALID_BUFFER);\n\n  function checkForbiddenStates() {\n    if (closed && takers.length) {\n      throw internalErr('Cannot have a closed channel with pending takers');\n    }\n\n    if (takers.length && !buffer.isEmpty()) {\n      throw internalErr('Cannot have pending takers with non empty buffer');\n    }\n  }\n\n  function put(input) {\n    checkForbiddenStates();\n    check(input, is.notUndef, UNDEFINED_INPUT_ERROR);\n\n    if (closed) {\n      return;\n    }\n\n    if (!takers.length) {\n      return buffer.put(input);\n    }\n\n    for (var i = 0; i < takers.length; i++) {\n      var cb = takers[i];\n\n      if (!cb[MATCH] || cb[MATCH](input)) {\n        takers.splice(i, 1);\n        return cb(input);\n      }\n    }\n  }\n\n  function take(cb) {\n    checkForbiddenStates();\n    check(cb, is.func, \"channel.take's callback must be a function\");\n\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n    } else if (!buffer.isEmpty()) {\n      cb(buffer.take());\n    } else {\n      takers.push(cb);\n\n      cb.cancel = function () {\n        return remove(takers, cb);\n      };\n    }\n  }\n\n  function flush(cb) {\n    checkForbiddenStates(); // TODO: check if some new state should be forbidden now\n\n    check(cb, is.func, \"channel.flush' callback must be a function\");\n\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n      return;\n    }\n\n    cb(buffer.flush());\n  }\n\n  function close() {\n    checkForbiddenStates();\n\n    if (!closed) {\n      closed = true;\n\n      if (takers.length) {\n        var arr = takers;\n        takers = [];\n\n        for (var i = 0, len = arr.length; i < len; i++) {\n          arr[i](END);\n        }\n      }\n    }\n  }\n\n  return {\n    take: take,\n    put: put,\n    flush: flush,\n    close: close,\n\n    get __takers__() {\n      return takers;\n    },\n\n    get __closed__() {\n      return closed;\n    }\n\n  };\n}\nexport function eventChannel(subscribe) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : buffers.none();\n  var matcher = arguments[2];\n  /**\r\n    should be if(typeof matcher !== undefined) instead?\r\n    see PR #273 for a background discussion\r\n  **/\n\n  if (arguments.length > 2) {\n    check(matcher, is.func, 'Invalid match function passed to eventChannel');\n  }\n\n  var chan = channel(buffer);\n\n  var close = function close() {\n    if (!chan.__closed__) {\n      if (unsubscribe) {\n        unsubscribe();\n      }\n\n      chan.close();\n    }\n  };\n\n  var unsubscribe = subscribe(function (input) {\n    if (isEnd(input)) {\n      close();\n      return;\n    }\n\n    if (matcher && !matcher(input)) {\n      return;\n    }\n\n    chan.put(input);\n  });\n\n  if (chan.__closed__) {\n    unsubscribe();\n  }\n\n  if (!is.func(unsubscribe)) {\n    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');\n  }\n\n  return {\n    take: chan.take,\n    flush: chan.flush,\n    close: close\n  };\n}\nexport function stdChannel(subscribe) {\n  var chan = eventChannel(function (cb) {\n    return subscribe(function (input) {\n      if (input[SAGA_ACTION]) {\n        cb(input);\n        return;\n      }\n\n      asap(function () {\n        return cb(input);\n      });\n    });\n  });\n  return _extends({}, chan, {\n    take: function take(cb, matcher) {\n      if (arguments.length > 1) {\n        check(matcher, is.func, \"channel.take's matcher argument must be a function\");\n        cb[MATCH] = matcher;\n      }\n\n      chan.take(cb);\n    }\n  });\n}","map":{"version":3,"sources":["D:/Projets/group-790626/jobillet/client/node_modules/redux-saga/es/internal/channel.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","is","check","remove","MATCH","internalErr","SAGA_ACTION","buffers","asap","CHANNEL_END_TYPE","END","type","isEnd","a","emitter","subscribers","subscribe","sub","push","emit","item","arr","slice","len","INVALID_BUFFER","UNDEFINED_INPUT_ERROR","process","env","NODE_ENV","channel","buffer","undefined","fixed","closed","takers","checkForbiddenStates","isEmpty","put","input","notUndef","cb","splice","take","func","cancel","flush","close","__takers__","__closed__","eventChannel","none","matcher","chan","unsubscribe","Error","stdChannel"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nimport { is, check, remove, MATCH, internalErr, SAGA_ACTION } from './utils';\r\nimport { buffers } from './buffers';\r\nimport { asap } from './scheduler';\r\n\r\nvar CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';\r\nexport var END = { type: CHANNEL_END_TYPE };\r\nexport var isEnd = function isEnd(a) {\r\n  return a && a.type === CHANNEL_END_TYPE;\r\n};\r\n\r\nexport function emitter() {\r\n  var subscribers = [];\r\n\r\n  function subscribe(sub) {\r\n    subscribers.push(sub);\r\n    return function () {\r\n      return remove(subscribers, sub);\r\n    };\r\n  }\r\n\r\n  function emit(item) {\r\n    var arr = subscribers.slice();\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      arr[i](item);\r\n    }\r\n  }\r\n\r\n  return {\r\n    subscribe: subscribe,\r\n    emit: emit\r\n  };\r\n}\r\n\r\nexport var INVALID_BUFFER = 'invalid buffer passed to channel factory function';\r\nexport var UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  UNDEFINED_INPUT_ERROR += '\\nHints:\\n    - check that your Action Creator returns a non-undefined value\\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\\n  ';\r\n}\r\n\r\nexport function channel() {\r\n  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : buffers.fixed();\r\n\r\n  var closed = false;\r\n  var takers = [];\r\n\r\n  check(buffer, is.buffer, INVALID_BUFFER);\r\n\r\n  function checkForbiddenStates() {\r\n    if (closed && takers.length) {\r\n      throw internalErr('Cannot have a closed channel with pending takers');\r\n    }\r\n    if (takers.length && !buffer.isEmpty()) {\r\n      throw internalErr('Cannot have pending takers with non empty buffer');\r\n    }\r\n  }\r\n\r\n  function put(input) {\r\n    checkForbiddenStates();\r\n    check(input, is.notUndef, UNDEFINED_INPUT_ERROR);\r\n    if (closed) {\r\n      return;\r\n    }\r\n    if (!takers.length) {\r\n      return buffer.put(input);\r\n    }\r\n    for (var i = 0; i < takers.length; i++) {\r\n      var cb = takers[i];\r\n      if (!cb[MATCH] || cb[MATCH](input)) {\r\n        takers.splice(i, 1);\r\n        return cb(input);\r\n      }\r\n    }\r\n  }\r\n\r\n  function take(cb) {\r\n    checkForbiddenStates();\r\n    check(cb, is.func, \"channel.take's callback must be a function\");\r\n\r\n    if (closed && buffer.isEmpty()) {\r\n      cb(END);\r\n    } else if (!buffer.isEmpty()) {\r\n      cb(buffer.take());\r\n    } else {\r\n      takers.push(cb);\r\n      cb.cancel = function () {\r\n        return remove(takers, cb);\r\n      };\r\n    }\r\n  }\r\n\r\n  function flush(cb) {\r\n    checkForbiddenStates(); // TODO: check if some new state should be forbidden now\r\n    check(cb, is.func, \"channel.flush' callback must be a function\");\r\n    if (closed && buffer.isEmpty()) {\r\n      cb(END);\r\n      return;\r\n    }\r\n    cb(buffer.flush());\r\n  }\r\n\r\n  function close() {\r\n    checkForbiddenStates();\r\n    if (!closed) {\r\n      closed = true;\r\n      if (takers.length) {\r\n        var arr = takers;\r\n        takers = [];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n          arr[i](END);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    take: take,\r\n    put: put,\r\n    flush: flush,\r\n    close: close,\r\n    get __takers__() {\r\n      return takers;\r\n    },\r\n    get __closed__() {\r\n      return closed;\r\n    }\r\n  };\r\n}\r\n\r\nexport function eventChannel(subscribe) {\r\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : buffers.none();\r\n  var matcher = arguments[2];\r\n\r\n  /**\r\n    should be if(typeof matcher !== undefined) instead?\r\n    see PR #273 for a background discussion\r\n  **/\r\n  if (arguments.length > 2) {\r\n    check(matcher, is.func, 'Invalid match function passed to eventChannel');\r\n  }\r\n\r\n  var chan = channel(buffer);\r\n  var close = function close() {\r\n    if (!chan.__closed__) {\r\n      if (unsubscribe) {\r\n        unsubscribe();\r\n      }\r\n      chan.close();\r\n    }\r\n  };\r\n  var unsubscribe = subscribe(function (input) {\r\n    if (isEnd(input)) {\r\n      close();\r\n      return;\r\n    }\r\n    if (matcher && !matcher(input)) {\r\n      return;\r\n    }\r\n    chan.put(input);\r\n  });\r\n  if (chan.__closed__) {\r\n    unsubscribe();\r\n  }\r\n\r\n  if (!is.func(unsubscribe)) {\r\n    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');\r\n  }\r\n\r\n  return {\r\n    take: chan.take,\r\n    flush: chan.flush,\r\n    close: close\r\n  };\r\n}\r\n\r\nexport function stdChannel(subscribe) {\r\n  var chan = eventChannel(function (cb) {\r\n    return subscribe(function (input) {\r\n      if (input[SAGA_ACTION]) {\r\n        cb(input);\r\n        return;\r\n      }\r\n      asap(function () {\r\n        return cb(input);\r\n      });\r\n    });\r\n  });\r\n\r\n  return _extends({}, chan, {\r\n    take: function take(cb, matcher) {\r\n      if (arguments.length > 1) {\r\n        check(matcher, is.func, \"channel.take's matcher argument must be a function\");\r\n        cb[MATCH] = matcher;\r\n      }\r\n      chan.take(cb);\r\n    }\r\n  });\r\n}"]},"metadata":{},"sourceType":"module"}